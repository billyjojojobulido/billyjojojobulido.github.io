

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/dog_icon.jpg">
  <link rel="icon" href="/img/dog_icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Baocheng Wang">
  <meta name="keywords" content="">
  
    <meta name="description" content="Data Structure and Algorithm - Two Pointers">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure and Algorithm - Two Pointers">
<meta property="og:url" content="https://billyjojojobulido.github.io/notes/Algorithm/twopointer/english/index.html">
<meta property="og:site_name" content="Baocheng Wang">
<meta property="og:description" content="Data Structure and Algorithm - Two Pointers">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-07-25T011:46:23.000Z">
<meta property="article:modified_time" content="2024-07-25T04:44:56.262Z">
<meta property="article:author" content="Baocheng Wang">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://billyjojojobulido.github.io/img/dog_icon.jpg">
  
  
  
  <title>Data Structure and Algorithm - Two Pointers</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库,不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">


<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"billyjojojobulido.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt){
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1')|| dntVal.startsWith('yes')|| dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Baocheng Wang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/notes/">
                <i class="iconfont icon-note"></i>
                <span>Notes</span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/projects/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Projects</span>
              </a>
            </li>

 

            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/stars.jpg')no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span>Data Structure and Algorithm - Two Pointers</span>
        </div>
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-25 23:15" pubdate>
          July 27, 2024
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12.9k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
          55 mins
        
      </span>
    
  </div>

      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">

            
              <div class="markdown-body">

<p>Two pointers problems are commonly easy and medium questions in Leetcode,, and may become difficult questions under specific question backgrounds and requirements. <br> If it is a sliding window, the difficulty is basically in the medium and difficult level.</p>

<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2>

<p>Two pointer is the first intermediate algorithm that most algorithm beginners can come up with individually on their way to advanced level.</p>

<p>When faced with a local search problem in an array (i.e. finding a segment that meets the conditions of arr[i:j]).
  Compared with O(N^2) brute force cracking, under certain requirements, algorithm beginners will start to think: Is there a way to solve the problem by searching the array only once?
</p>

<p>After some hearty thinking, the beginner will realize that
  <span style="font-weight: bold;">
    Compared with the mindless movement of the two search pointers i and j by brute force, 
    it is entirely possible to record more meaningful content by customizing the movement rules of the pointers, 
    thereby ignoring some unnecessary repeated searches
  </span> 
  and achieving O(N) time complexity.
</p>

<p>It is also at this time that most beginners begin to realize the meaning of exchanging space (complexity) for time (complexity).</p>

<p><strong>Of course, double pointer is a very general and rough name. Any algorithm that uses two pointers with specific movement rules can be called double pointer.</strong>
  Therefore, the binary search method can also be regarded as a double-pointer algorithm, but the essence of the binary search algorithm still lies in the core idea of binary search.</p>


<h3 id="categories">Categories of Two Pointers</h3>
<p>We can categorize the Two Pointers into four main categories based on the moving pattern of the two pointers.</p>
<ol>
  <li style="font-weight: bold;">Left & Right / Head & Tail / Collision</li>
  <strong>Feature: One array, move from two sides to the middle / towards each other</strong>
  <p style="font-weight: bold;">Usually used in: search in ordered array (binary search)</p>

  <li style="font-weight: bold;">Fast & Slow (Forward)</li>
  <strong>Feature: One array, both move forward/the same direction, in different pattern</strong><br>
  <p style="font-weight: bold;">Usually used in: Linked List, search for cycle / middle point</p>

  <li style="font-weight: bold;">Parallel</li>
  <stonrg>Feature: Two arrays, each array has been assigned a pointer.</stonrg><br>
  <p style="font-weight: bold;">Usually used in: Searching in more than one array & Merging two sorted sub-arraies in Merge Sort.</p>

  <li style="font-weight: bold;">Sliding Window</li>
  <strong>Feature: Both pointers moving in the same direction at a fixed difference of k.</strong>
  <p style="font-weight: bold;">Usually used in: subarray, string, substring</p>
</ol>


<h2 id="Difficulty"><a href="#Difficulty" class="headerlink" title="Difficulty"></a>Difficulty in Two Pointers⭐️</h2>
<p>There are generally only two difficulties, corresponding to design and implementation:</p>
<ol>
  <li><span style="font-weight: bold;">Design: </span>Is it possible to clearly define the movement strategies of the two pointers (what are the two pointers used for?)</li>
  <li><span style="font-weight: bold;">Implementation: </span>Can you take all edge cases into account during coding (can you write them down or not)?</li>
</ol>

<strong>Difficulty 1</strong>
<p>Usually it is because of lack of sufficient practice that one does not think of using the two-pointer algorithm 
  [which is the most inappropriate thing], or one cannot figure out the movement logic of the two pointers, 
  resulting in failure in solving the problem.
  <span style="font-weight: bold;">Therefore, for Difficulty 1, there is no other technique except practicing more.</span>
</p>


<strong>Difficulty 2</strong>
<p>The other problem is that you lack sufficient coding skills and lose patience or make mistakes when dealing with complex logic. 
  Unlike Difficulty 1, this problem can be solved with some skills.</p>

<h3 id="trick">Trick:「Loop Invariant」</h3>

<strong>The loop invariant refers to an unchanging property that we must follow when writing code.</strong>

<p>This property requires us to define it according to the problem, 
  <span style="font-weight: bold;">
    It is important to ensure that the three stages of 「initialization」, 「loop traversal」 and 「ending」
     have the same properties so that a problem can be solved correctly.
  </span></p>

<p style="font-size: x-large; font-weight: bold; font-style: italic;">Different definitions of intervals determine different initialization logic and logic during the traversal process.</p>

<p style="font-weight: bold;">Therefore, the loop invariant is not the essence of the so-called two-pointer algorithm, 
  but a technique to write a two-pointer solution sufficiently thorough for complex problems.</p> 
  This trick can also apply to other algorithms.



<h2 id="Classic"><a href="#Classic" class="headerlink" title="Classic"></a>Problem Collection of Classic Two Pointers</h2>

<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Problem</th>
      <th>Diff</th>
      <th>Two Pointers Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>26</td>
      <td>Remove Duplicates from Sorted Array</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: Keep searching for next unknown element. <br>
          Slow pointer: Locate the position to fill the next element</p>
      </td>
    </tr>
    <tr>
      <td>674</td>
      <td>Longest Continuous Increasing Subsequence</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: Keep searching for the next element that satisfies the monotonically increasing<br>
          Slow pointer: Locates the start of this incrementing sequence</p>
        <p>When the fast pointer element violates monotonically increasing, the slow pointer moves to the position of the current fast pointer, which means searching for a new increasing sequence.</p>
      </td>
    </tr>
    <tr>
      <td>977</td>
      <td>Squares of a Sorted Array</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>Type: Collision</strong><br>
        <p>Left pointer: Indicates that the negative end may compete for the element with the maximum value after square<br>
          Right pointer: Indicates that the positive end may compete for the element with the maximum value after square</p>
        <p>Hint: When negative and positive numbers can be excluded, the result can be directly output</p>
      </td>
    </tr>
    <tr>
      <td>27</td>
      <td>Remove Element</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: Constantly looking for the next element that does not need to be removed<br>
          Slow pointer: Locates the next element to be filled</p>
      </td>
    </tr>
    <tr>
      <td>80</td>
      <td>Remove Duplicates from Sorted Array II</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: Continuously searches for the next element and decides whether to insert and update the reference element based on the number of repetitions.<br>
          Slow pointer: Locates the insertion position of the next element</p>
          <strong>Difficulty: A special restriction of "no more than two repetitions" was added to question 26, but it is just an additional judgment, not complicated.</strong>
      </td>
    </tr>
    <tr>
      <td>283</td>
      <td>Move Zeroes</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: Keep looking for the next non-zero element<br>
          Slow pointer: Locates the insertion position of the next non-zero element </p>
          <strong>Hint: Can fill up all the 0 using the interval [slow:n) at last.</strong>
      </td>
    </tr>
    <tr>
      <td>11</td>
      <td>Container With Most Water</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>Type: Collision</strong><br>
        <p>Left pointer: Points to the left border of the current traversal layer<br>
          Right pointer: Points to the right border of the current traversal layer
          </p>
          <strong>Pointer Pattern: [Greedy] Always move the shorter side, because the length decreases at a fixed rate, and there is no loss in replacing the shorter side.</strong>
      </td>
    </tr>

  </tbody>
</table>


<h2 id="Unchange"><a href="#Unchange" class="headerlink" title="Unchange"></a>Problem Collection of Tricky Loop Invariant Two Pointers </h2>

<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Problem</th>
      <th>Diff</th>
      <th>Two Pointers Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>75</td>
      <td>Sort Colors</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>【Dutch National Flag Problem⭐️】</strong><br>
        <strong>Type: Collision [variant]</strong><br>
        <p>
          Fast pointer: Locate the position to swap 1<br>
          Slow pointer: Locate the position to swap 2<br>
          In the Dutch flag problem, a single pointer O(2N) can also be used. 
          The moving strategy of the two pointers in the double pointer solution is inconsistent with the conventional collision pointer.</p>

          <strong>Difficulty: Consider the case [2, 1, 2]<br>
            There exists a situation where both right pointer and i are 2, so we need to use "while i &lt= right and nums[i] == 2: … right -= 1" to make sure that we won't miss the 2 on the left [if we takes the index from 0 to n-1 by default]
            </strong>
      </td>
    </tr>
    <tr>
      <td>215</td>
      <td>Kth Largest Element in an Array</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>[A variant of Quick Sort]</strong><br>
        <strong>Type: Collision [variant]</strong><br>
        <p>The left and right pointers are not prestigiously distinguished, with the <strong>Sentinel Division</strong> and <strong>Recursion</strong> to partition the left & right of the pivot, till the end.</p>
        <strong>Trick: Quick Selection</strong><br>
        <p>The question requires finding the Kth largest value, so there is no need to sort the array. 
          Instead, it is similar to a binary search. When the number on the left and right sides of the pivot can determine that the Kth largest value does not exist in an interval, 
          the interval can be discarded directly.</p>
        <strong>Because the time complexity is required to be O(N), it is obviously a divide-and-conquer algorithm.</strong>
      </td>
    </tr>
    <tr>
      <td>59</td>
      <td>Spiral Matrix II</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>【Simulation Method based on Loop Invariant】</strong><br>
        <strong>Loop Invariant: Simulated by layer, and there are 4 edges in each layer, can be represented by the intervals:[left,right), [up, down),[right, left), [down, up).</strong><br>
        <strong>Till all the layers are traversed.</strong>
      </td>
    </tr>
  </tbody>
</table>


<h2 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Problem Collection of Two Pointers in Linked List</h2>

<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Problem</th>
      <th>Diff</th>
      <th>Two Pointer Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>141</td>
      <td>Linked List Cycle</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: traverse 2 nodes each step.<br>          
          Slow pointer: traverse 1 node each step.</p>

          <strong>[Trick]: If there is a cycle, then the two pointers will eventually meet, otherwise the fast pointer can easily reach the tail.</strong>
      </td>
    </tr>
    <tr>
      <td>19</td>
      <td>Remove Nth Node From End of List</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: N nodes ahead of slow pointer.<br>
          Slow pointer: starts from the【dummy head】
        </p>
        <p>If the fast pointer has reached the end, then directly remove the next node at the slow pointer.</p>
      </td>
    </tr>
    <tr>
      <td>876</td>
      <td>Middle of the Linked List</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: traverse 2 nodes at a time.<br>
         Slow pointer: traverse 1 node at a time.
          </p>
        <strong>Once the fast pointer reached the end, directly return the node pointed by slow pointer.</strong>
      </td>
    </tr>
    <tr>
      <td>142</td>
      <td>Linked List Cycle II</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>Type: Fast & Slow</strong><br>
        <p>Fast pointer: traverse 2 nodes at a time.<br>
          Slow pointer: traverse 1 node at a time.     
        </p>
        <strong>Difficulty: O(1) time complexity to find the entrance of cycle.</strong><br>
        <p><span style="font-weight: bold;">Might need some mathematical mindset</span>
          Assume there are a nodes before the entrance of cycle, and there are b nodes in cycle, you will notice:
        </p>
        <p>Once the two pointers meet, the fast pointer mvoe twice the nodes than slow pointer, so we can have:</p>
        <ul>
          <li style="font-weight: bold;">2x = a + M*b + w           [w is the index of node in cycle]</li>
          <li style="font-weight: bold;">x = a + N*b + w</li>
        </ul>
        <p>Substract x from 2x, and we can prove that</p>
        <ul><li style="font-weight: bold;">x = (M - N) * b             [let M-N = k]</li></ul>
        <strong>This means that it only takes `a` more steps for the slow pointer to find the entrance of cycle (a + k * b).</strong>
        <p>Now we need to reconstruct the Fast & Slow pointers, and the slow pointer can point back to head, and the two pointers now need to walk in the same pace, 
          <span style="font-weight: bold;">so they will meet at the entrance of the cycle.</span></p>
      </td>
    </tr>
    <tr>
      <td>160</td>
      <td>Intersection of Two Linked Lists</td>
      <td style="background-color: lightgreen;">Easy</td>
      <td>
        <strong>[This question does not require space complexity, and can be solved with a hash table, so it is a simple question, 
          but the double pointer can be O(1) space, O(m+n) time, this step is a little difficult, 
          it is considered medium difficulty]</strong><br>
        <strong>Type: Two Single Pointers</strong><br>
        <p><span style="font-weight: bold;">Trick: the core technique is actually to align the two linked lists.</span>
          You can find the length by traversing, and then align the two according to the length, and then traverse both linked lists synchronously from the beginning with a pointer. 
          When you traverse to the same node, it is the intersection entrance.
        </p>
      </td>
    </tr>
  </tbody>
</table>

<h2 id="Dedup"><a href="#Dedup" class="headerlink" title="Dedup"></a>Problem Collection of Two Pointers Improving Deduplication</h2>
<p></p>
<p><strong>This type of problem usually has one or more typical solutions, but the algorithm that simplifies the retrieving process often makes the deduplication process more complicated. 
  The deduplication complexity can be simplified by using sorted double pointers.</strong></p>
<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Problem</th>
      <th>Diff</th>
      <th>Two Pointer Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>15</td>
      <td>3Sum</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <strong>【Hash Map Solution】</strong>
        <p>On the basis of two sum, the most typical solution would be Hash Map, which only takes two nested for loop to determine the value of a + b.
          And then determine wheter 0-(a+b) exists in the array using HashMap. This idea is actually correct. However, the major issue is deduplication, as the question
          suggests that the return array should not contain any duplicated combination.</p>
          <p>It is very time-consuming to first find all the unique triples in the index through hashing and then remove them, which may easily time out.</p>
        <strong>It would be more efficient to solve this problem by using two pointers than hashmaps</strong><br>
        <p>Due to the complexity of this problem, the double pointer type we are going to use is also quite special, which I call: <strong>Nested Collision Pointers</strong></p>
        <p>First we need to sort the array, and has a for loop, where i starts from index 0, and init a pointer left starting at index i+1, along with another pointer right
          starting at the end of the array.</p>

        <strong>Pointers Startegy</strong><br>
        <p>if nums[i] + nums[left] + nums[right] &gt 0, then it means that the three sum is too large, and as the array has been sorted, so the right pointer needs to be moves to its left</p>
        <p>if nums[i] + nums[left] + nums[right] &lt 0, then it means that the three sum is too small, so left needs to go right, until left and right eventually meet.</p>
      </td>
    </tr>

    <tr>
      <td>18</td>
      <td>4Sum</td>
      <td style="background-color: yellow;">Medium</td>
      <td>
        <p>The same idea with 15. 3Sum. Using Two Pointers, and only requires one more for loop nested on the basis of 3Sum.</p>

        <p>The solution is to have two nested for loop, where nums[k] + nums[i] are certain, and still have left and right pointers within each for loop,
          and move based on the three situations of: nums[k] + nums[i] + nums[left] + nums[right] == target, 
          The time complexsity of 3Sum is O(n^2), where the time complexsity of 4Sum is O(n^3) 。</p>
        <p>Likewise, 5Sum, 6Sum, etc can be solved in similar manners.</p>
      </td>
    </tr>

  </tbody>
</table>

<p><strong>Think: Can we simplifies the Two Sum problem using Two Pointers?</strong></p>

<p>The answer is <strong>NO</strong>. It is very simple, because the Two Sum problem needs us to return index, instead of values, so we cannot sort the array.
</p>

<strong>Note: You can get more Two Pointers exercises through the [Similar Questions] function of Leetcode</strong><br>


<h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>References</h2>
<ul>
<ul>
  <li><a target="_blank" rel="noopener" href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">Carol's Code Thoughts: Two Pointers - Public Talk</a></li>
  <li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html#%E6%95%B0%E7%BB%84%E7%AF%87">Carol's Code Thoughts: Summary of Two Pointers [translated]</a></li>
  <li><a target="_blank" rel="noopener" href="https://oi-wiki.org/misc/two-pointer/">OI Wiki: Two Pointers</a></li>
  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/top-interview-150/">Leetcode: Top Interview 150</a></li>
  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/premium-algo-100/">Leetcode: Premium Algorithm 100</a></li>
  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/">Leetcode Problem Set</a></li>

</ul>
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
      <a href="/tags/General/Tech/" class="print-no-link">#Tech</a>
    </div>
  
</div>



  <div class="license-box my-3">
    <div class="license-title">
      <div>Data Structure and Algorithm - Two Pointers</div>
      <div>https://billyjojojobulidogithub.io/notes/Algorithm/twopointer/english/index.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Baocheng Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>July 27, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                    <i class="iconfont icon-nc"></i>
                    <i class="iconfont icon-nd"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>

                <div class="post-prevnext my-3">
                  <!-- <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/30/USYD/" title="USYD Graduation">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Baocheng's Graduation from the University of Sydney</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/15/Navigator/" title="Government Infrastructure Performance Navigator">
                        <span class="hidden-mobile">Government Infrastructure Performance Navigator</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article> -->
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>

      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  

</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function(){
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document){
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing){
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function(){
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot){ return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0){
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function(){
      if ('tocbot' in window){
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot){
          return;
        }
        if (toc.find('.toc-list-item').length > 0){
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function(){
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon){
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el){
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left'){
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function(){
      if ('anchors' in window){
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el){
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left'){
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function(){
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项,将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
