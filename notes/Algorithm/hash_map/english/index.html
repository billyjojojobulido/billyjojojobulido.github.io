

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/dog_icon.jpg">
  <link rel="icon" href="/img/dog_icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Baocheng Wang">
  <meta name="keywords" content="">
  
    <meta name="description" content="Data Structure and Algorithm - Hash Map">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure and Algorithm - Hash Map">
<meta property="og:url" content="https://billyjojojobulido.github.io/notes/Algorithm/hash_map/english/index.html">
<meta property="og:site_name" content="Baocheng Wang">
<meta property="og:description" content="Data Structure and Algorithm - Hash Map">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-04T011:39:23.000Z">
<meta property="article:modified_time" content="2024-11-04T11:39:56.262Z">
<meta property="article:author" content="Baocheng Wang">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://billyjojojobulido.github.io/img/dog_icon.jpg">
  
  
  
  <title>Data Structure and Algorithm - Hash Map</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- ‰∏ªÈ¢ò‰æùËµñÁöÑÂõæÊ†áÂ∫ì,‰∏çË¶ÅËá™Ë°å‰øÆÊîπ -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">


<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"billyjojojobulido.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt){
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1')|| dntVal.startsWith('yes')|| dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Baocheng Wang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/notes/">
                <i class="iconfont icon-note"></i>
                <span>Notes</span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/projects/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Projects</span>
              </a>
            </li>

 

            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/stars.jpg')no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span>Data Structure and Algorithm - Hash Map</span>
        </div>
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-04 11:40" pubdate>
          November 04, 2024
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14.8k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
          60 mins
        
      </span>
    
  </div>

      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">

            
              <div class="markdown-body">

                <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2>

                <p>The hash table is a basic data structure that is highly valued by developers and widely used in practical development. It is also a frequently tested data structure in interviews and algorithm assessments. It's a classic example of a space-for-time algorithm.</p>
                
                <p style="font-weight: bold;">If an array is akin to a pawn in chess, suitable for basic algorithms and steady progression, but always ready to make way for mid-to-high-level algorithms, then a hash table is like a knight in chess: when used at the right moment, this simple data structure can achieve effects comparable to any advanced algorithm.</p>
                
                <p>The hash table is so highly regarded because it can guarantee O(1) time complexity for lookups. Therefore, <strong>hash tables are generally used to quickly check if an element exists in a set</strong>, something that linked lists and arrays cannot easily accomplish.</p>
                
                <h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Theoretical Basis of Hash Tables</h2>
                <p>
                    First, the official definition of a hash table is fairly straightforward: <strong>"A hash table is a data structure that accesses data directly based on the value of the key."</strong>
                </p>
                
                <div style="text-align: center;">
                  <img src="../img/map.png" width="50%">
                </div>
                <p>
                  Based on this definition, we could say that arrays are also a type of hash table. However, to avoid ambiguity, it's necessary to clarify that when I refer to "array algorithms," I mean "arrays (as a data structure) + algorithms based on the structural properties of arrays (e.g., binary search, prefix sum, etc.)."
                </p>
                
                <p>Of course, the popularity of hash tables is driven by reasons far more complex than just a simplistic O(1) search. While arrays can also achieve O(1) time complexity for searches, this is limited to index-based searches. If the search key cannot serve as an index in practical applications, this approach falls short.</p>
                
                <p><strong>The principle behind hash tables represents the culmination of efforts by pioneers in computer science to tackle this issue, along with various historical challenges, and ultimately arriving at an optimal solution.</strong></p>
                
                <p>
                  Imagine a time before hash tables were invented, when all constant-time searches relied on arrays.
                  Naturally, the first historical problem that arose was <strong>"how to transform a non-integer key into an integer index that an array can use."</strong>
                  Thus, when people attempted to solve the issue of "performing constant-time searches based on a string key," the most straightforward solution was: "simply find a way to convert the string into an integer to use as an index," allowing O(1) searches based on arrays.
                </p>
                
                <div style="text-align: center;">
                  <img src="../img/hash_func.png" width="50%">
                </div>
                
                <p>From an engineering perspective, this solution is quite practical because it allows us to efficiently use existing resources (arrays) by developing a logic to convert strings to integers. 
                    While there are many ways to convert a string to an integer, the simplest method is using the ASCII decimal representation of the string characters. However, this approach is not adopted because the resulting array size would grow without bound as the string length increases, theoretically requiring larger arrays to accommodate the corresponding indices.
                    We don't even need to discuss whether the indices are sparsely distributed; the fact that the upper bound of space complexity depends on the length of the longest string already makes this approach unacceptable for developers.</p>
                    
                <p>Therefore, from a performance perspective, an ideal conversion logic must meet the following criteria to make building an ideal hash table possible:</p>
                
                <ol>
                    <li><strong>"Strong Determinism": The generated integer must be reproducible.</strong> The same string must generate the same integer <strong>(otherwise, the search is meaningless).</strong></li>
                    <li><strong>"Collision Resistance": The generated integer should be unique.</strong> Different strings should generate different integers <strong>(otherwise, information could be unintentionally overwritten).</strong></li>
                    <li><strong>"Controlled Range": The generated integer should have a limited range.</strong> The range of generated integers should be predictable <strong>(otherwise, memory usage could become excessive).</strong></li>
                </ol>
                
                <p>Mathematicians developed this approach long ago, known as the <strong>Hash Function</strong>.</p>
                
                <h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash Function</h2>

                <p>A hash function is a mathematical method derived from cryptography that can convert other data formats into different values through a specific process (<code>hashCode</code>), allowing non-integer keys to be mapped to array indices.</p>
                
                <p>Beyond type conversion, the most remarkable feature of hash functions is their <strong>"irreversibility."</strong> Given <code>A = hash(B)</code>, if I know <code>B</code>, I can always find <code>A</code>, but knowing <code>A</code> does not allow me to determine what <code>B</code> is. A simple example is:</p>
                <pre>
                    def hash(val):
                        return "0" if val % 2 == 0 else "1"
                </pre>
                
                <p>In the above example, I can get the hash value "1" based on the oddness of <code>val = 7</code>, but from the hash value, I can at most infer that <code>val</code> is odd, without knowing the exact odd number.</p>
                
                <p>This is a general characteristic of hash functions, which is why they are widely used in network security and blockchain. They allow users to hash sensitive data/passwords/keys and share them without fear of decoding (though this also requires following an entire asymmetric encryption protocol).</p>
                
                <p>While the above discussion on cryptography and network security is tangential, it reveals a limitation of hash functions: <strong>they cannot guarantee uniqueness.</strong> There are cases where two different strings, <code>A</code> and <code>B</code>, may produce the same hash result, <code>hash(A) = hash(B)</code>. This phenomenon is called a <strong>"hash collision."</strong> 
                    Although this probability may be small, it cannot be ignored in applications due to memory trade-offs. (Note: The likelihood of hash collisions depends on the hash space, which is the range of integers after mapping. The smaller the hash space, the more likely collisions become.)</p>
                    
                <p>For example, the commonly used SHA-2 hash function in blockchain has a large hash space, making hash collisions virtually negligible. However, this means it generates hashes over the entire 32-bit integer range, implying the need for an array of size <code>2**32</code>, which is impractical. Thus, a tradeoff is necessary:
                    <strong>"a higher collision probability for reduced memory usage."</strong>
                </p>
                
                <p>This brings us to the second historical problem: <strong>"hash collisions."</strong> If hash collisions cannot be addressed, hash functions remain impractical.</p>
                
                <h2 id="Collision"><a href="#Collision" class="headerlink" title="Collision"></a>Solutions to Hash Collisions</h2>

                <p>Hash collisions are inherently a probability issue, so preventing collisions entirely is an unsolvable problem. From the perspective of discrete mathematics, increasing the hash space can reduce the likelihood of collisions, but it can't eliminate the probability entirely. Since collisions are inevitable, let's focus on how to handle them when they occur.</p>
                
                <p>The essence of the collision problem is actually a conflict problem. When a "hash collision" occurs, it means that at least two different keys point to the same memory block, and both stored values are equally meaningful, so neither can be discarded. Overwriting the original key with a new value could result in unexpected values during searches, potentially leading to severe issues.</p>
                
                <p>Thus, the only reasonable solution is to consider how to <strong>"store all collision results and distinguish them during lookup."</strong></p>
                
                <p>Clearly, "storing collision results" is much simpler than "avoiding collisions." The most straightforward approach is to "improve the hash table structure" to allow it to function correctly even with hash collisions.</p>
                
                <p>In practice, there are two main structural improvements for hash tables: <strong>"Separate Chaining"</strong> and <strong>"Open Addressing."</strong></p>
                
                <h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>"Separate Chaining"</h3>
                
                <p>In a basic hash table, each memory block (also called a "bucket") can store only one key-value pair. Separate chaining converts a single element into a linked list, with key-value pairs as nodes, storing all colliding key-value pairs in the same linked list.</p>
                
                <p>From a learner's perspective, a question might arise (at least it puzzled me for a while when I was learning): since the hashed keys are already the same, how do we find the desired element in the linked list?</p>
                
                <p>For a developer, this is quite simple to address. By retaining the original, pre-hashed key in the data structure, we can locate the specific element in the linked list when a hash collision occurs.</p>
                
                <p>With this, the basic principle of "Separate Chaining" is clear, and we can design the following data structure.</p>
                
                <div style="text-align: center;">
                  <img src="../img/chain.png" width="40%">
                </div>
                

                <h4>Limitations of Separate Chaining</h4>
                <ol>
                  <li><strong>Increased space usage:</strong> Adding a linked list structure to the original array requires node pointers, which consumes more memory.</li>
                  <li><strong>Reduced search efficiency:</strong> With the addition of linked lists, linear search time complexity is introduced. Although it only occurs during "hash collisions," the worst case is equivalent to a linear search through the linked list.</li>
                </ol>
                 
                <h3 id="Open"><a href="#Open" class="headerlink" title="Open"></a>"Open Addressing"</h3>
                
                <p>While "Separate Chaining" solves the "hash collision" problem, it introduces additional data structures, which may not be optimal for performance. 
                    Particularly when developers consider the pessimistic scenario‚Äîwhere all elements collide and cluster in one bucket‚Äîthe search efficiency would degrade to O(N) time complexity.</p>
                
                <p>At this point, many developers notice that since hash tables don't require contiguous insertions, memory usage is actually sparse, scattered, and inefficient. Given that there's so much unused memory, why add linked lists to handle collisions?</p>
                
                <p>This is where the concept of <strong>"Open Addressing"</strong> emerges.</p>
                
                <p>Unlike separate chaining, which relies on extra data structures, the main difference with open addressing is that it doesn't "solve the problem in place." Personally, I find that the open addressing approach aligns more with real-world logic: 
                    if people find their seat occupied, their first instinct is to sit in the next available spot rather than bring a new chair. (This is actually how I grasped the concept of open addressing ü§¶)</p>
                
                <p>However, this raises a question: Separate chaining uses extra data structures to handle collisions "in place" for easy lookup, since the hash value directly points to a single bucket. But with open addressing, placing entries in adjacent buckets‚Äîhow will we find them during lookups?</p>
                
                <p>We can think a bit further: when a collision occurs, we place the new key-value pair in the next available bucket. But if the "primary owner" of this bucket, the initial hash value intended for that spot, arrives later, how will it know the spot is occupied due to another key's collision?</p>
                
                <p>This requires the algorithm to actively <strong>probe</strong> for handling hash collisions, introducing another method called <strong>"Linear Probing."</strong></p>
                
                <p>The probing logic is straightforward: if the bucket pointed to by the hash value is not empty, a collision has occurred. I then use a fixed step size to probe forward from the hash bucket. When I find a bucket with a matching original key, I lock in that position. 
                    If I encounter an empty bucket during probing, it means the key doesn't exist, as by the insertion rule, an empty bucket wouldn't appear before locating the value.</p>
                
                <div style="text-align: center;">
                  <img src="../img/open_address.png" height="300px">
                </div>
                
                <p>If you're observant, you might notice an issue with this approach: if an insertion encounters a conflict and is placed in the nearest empty bucket, what happens if an element between the original bucket and the insertion bucket is deleted? According to the current "linear probing" logic, probing stops when it encounters an empty bucket, rendering the inserted value meaningless.</p>

                <p>The solution to this problem is simpler and more straightforward than it seems: instead of removing elements from the bucket, we <strong>use a specific constant, "TOMBSTONE," to mark the bucket</strong>. This way, linear probing won't prematurely terminate due to an empty bucket, and new values can still be inserted.</p>
                
                <p>This approach is called <strong>"Lazy Deletion."</strong></p>
                
                <h4>"Clustering" in Linear Probing</h4>
                <p>When hash collisions occur frequently, constant overwriting to place values in the nearest available bucket results in increasingly long occupied sequences within the underlying array. This increases the likelihood of further collisions, creating a vicious cycle of clustering. In such cases, each lookup incurs a considerable overhead.</p>
                
                <p>Besides "linear probing," there are other probing methods like "quadratic probing" and "double hashing," both commonly used in open addressing strategies. These two methods aim to mitigate the clustering problem in linear probing.</p>
                
                <h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Additional Optimization: Red-Black Tree (Detailed in the Tree Chapter)</h3>

                <p>In principle, hash tables are already robust enough as standalone data structures. However, some cautious (in a non-pejorative sense ü§ê) pioneers in computer science have raised new concerns about hash collisions, leading to our final historical issue: <strong>"How to handle the query performance problem of long linked lists when numerous hash collisions occur."</strong></p>
                
                <p>This issue is not too distant from us and is still somewhat controversial. Most programming languages haven't made adjustments for this problem. Currently, only Java and C++ have modified the underlying implementation of HashMap, using a "Red-Black Tree" in certain cases to replace the linked list, thereby improving search efficiency from O(n) to O(log n) when a large number of collisions occur.</p>
                
                <h2 id="Classic"><a href="#Classic" class="headerlink" title="Classic"></a>Hash Table Performance Comparison</h2>
                <table>
                  <thead>
                    <tr>
                      <th></th>
                      <th>Array</th>
                      <th>Linked List</th>
                      <th>Hash Table</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Search Element</td>
                      <td>O(1)</td>
                      <td>O(N)</td>
                      <td>O(1)</td>
                    </tr>
                
                    <tr>
                      <td>Add Element</td>
                      <td>O(N)</td>
                      <td>O(1)</td>
                      <td>O(1)</td>
                    </tr>
                
                    <tr>
                      <td>Delete Element</td>
                      <td>O(N)</td>
                      <td>O(1)</td>
                      <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>Traverse All Elements</td>
                        <td>O(N)</td>
                        <td>O(N)</td>
                        <td>O(N)</td>
                      </tr>
                  </tbody>
                </table>


                <h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Problem-Solving Experience Summary</h2>

<h3 id="straight">Conclusion: When to Use Hash Tables?</h3>
<p>
<strong>When we need to check if an element has appeared or if an element is in a set, hash tables should be the first method to consider.</strong>
</p>
<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Name</th>
      <th>Difficulty</th>
      <th>Hash-Based Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
        <td>1</td>
        <td>Two Sum</td>
        <td style="background-color: lightgreen;">Easy</td>
        <td>
            The first problem in the entire LeetCode library is a classic hash table problem, as we need to check if the complementary element for element i has already been seen while iterating.
        </td>
      </tr>
    <tr>
        <td>202</td>
        <td>Happy Number</td>
        <td style="background-color: lightgreen;">Easy</td>
        <td>
            As the problem states, during the sum process, the sum may repeat. Therefore, we can use a hash table to check if the sum has appeared before.
        </td>
    </tr>
    <tr>
        <td>242</td>
        <td>Valid Anagram</td>
        <td style="background-color: lightgreen;">Easy</td>
        <td>
            The brute-force solution requires two nested loops, but we can define a hash table to record character occurrences in <code>s</code> in a single loop. (Since the problem only includes 26 lowercase letters, a length-26 array can replace the hash table.)
        </td>
    </tr>
    <tr>
        <td>349</td>
        <td>Intersection of Two Arrays</td>
        <td style="background-color: lightgreen;">Easy</td>
        <td>
            Instead of repeatedly iterating over array A to find intersections, it's more efficient to store elements of A in a hash table and check if elements from B exist in A in O(1) time.
        </td>
    </tr>
    <tr>
        <td>383</td>
        <td>Ransom Note</td>
        <td style="background-color: lightgreen;">Easy</td>
        <td>
            Since the problem only includes lowercase letters, we can use a space-for-time strategy with a hash table, using a length-26 array to record letter occurrences in <code>magazine</code>.
        </td>
    </tr>
    <tr>
        <td>454</td>
        <td>4Sum II</td>
        <td style="background-color: yellow;">Medium</td>
        <td>
            Unlike Two Sum, this problem involves more variables, making O(N) infeasible. By defining a hash table where the key is the sum of <code>a</code> and <code>b</code> and the value is their occurrence count, we can reduce the time complexity from O(N^4) to O(N^2) by iterating through <code>C + D</code>.
        </td>
    </tr>
  </tbody>
</table>
                
                <h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>References</h2>
                <ul>
                  <li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8">Programmer Carl: Hash Table Theory Basics</a></li>
                  <li><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_collision/">Hello Algo: Hash Collisions</a></li>
                  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/top-interview-150/">LeetCode: Top Interview 150 Questions</a></li>
                  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/premium-algo-100/">LeetCode: Premium Interview 100 Questions</a></li>
                  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/">LeetCode Algorithms</a></li>
                </ul>
                
</ul>
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
      <a href="/tags/General/Tech/" class="print-no-link">#Tech</a>
    </div>
  
</div>



  <div class="license-box my-3">
    <div class="license-title">
      <div>Data Structure and Algorithm - Hash Map</div>
      <div>https://billyjojojobulidogithub.io/notes/Algorithm/hash_map/english/index.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Baocheng Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>November 04, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                    <i class="iconfont icon-nc"></i>
                    <i class="iconfont icon-nd"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>

                <div class="post-prevnext my-3">
                  <!-- <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/30/USYD/" title="USYD Graduation">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Baocheng's Graduation from the University of Sydney</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/15/Navigator/" title="Government Infrastructure Performance Navigator">
                        <span class="hidden-mobile">Government Infrastructure Performance Navigator</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article> -->
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
      <p class="toc-header">
        <i class="iconfont icon-list"></i>
        <span>Table of Contents</span>
      </p>
      <div class="toc-body" id="toc-body"></div>
    </div>
  </aside>


    </div>
  </div>
</div>

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>

      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  

</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function(){
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document){
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing){
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function(){
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot){ return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0){
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function(){
      if ('tocbot' in window){
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot){
          return;
        }
        if (toc.find('.toc-list-item').length > 0){
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function(){
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon){
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el){
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left'){
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function(){
      if ('anchors' in window){
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el){
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left'){
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function(){
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- ‰∏ªÈ¢òÁöÑÂêØÂä®È°π,Â∞ÜÂÆÉ‰øùÊåÅÂú®ÊúÄÂ∫ïÈÉ® -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>