

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/dog_icon.jpg">
  <link rel="icon" href="/img/dog_icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Baocheng Wang">
  <meta name="keywords" content="">
  
    <meta name="description" content="Data Structure and Algorithm - Array(II): Sorting">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure and Algorithm - Array(II): Sorting">
<meta property="og:url" content="https://billyjojojobulido.github.io/notes/Algorithm/sort/english/index.html">
<meta property="og:site_name" content="Baocheng Wang">
<meta property="og:description" content="Data Structure and Algorithm - Array(II): Sorting">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-08-08T011:46:23.000Z">
<meta property="article:modified_time" content="2024-08-08T04:44:56.262Z">
<meta property="article:author" content="Baocheng Wang">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://billyjojojobulido.github.io/img/dog_icon.jpg">
  
  
  
  <title>Data Structure and Algorithm - Array(II): Sorting</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库,不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">


<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"billyjojojobulido.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt){
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1')|| dntVal.startsWith('yes')|| dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Baocheng Wang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/notes/">
                <i class="iconfont icon-note"></i>
                <span>Notes</span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/projects/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Projects</span>
              </a>
            </li>

 

            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/stars.jpg')no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span>Data Structure and Algorithm - Array(II): Sorting</span>
        </div>
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-05 13:15" pubdate>
          August 08, 2024
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.6k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
          50 mins
        
      </span>
    
  </div>

      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">

            
              <div class="markdown-body">


<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2>
<p style="font-weight: bold;">Sorting an unordered array is one of the most common utility algorithms in interviews.</p>
<p>Sorting algorithms alone might not be challenging enough to be a standalone interview question. Therefore, sorting is often used to assist other algorithms, such as binary search and greedy algorithms. However, some interviewers may ask candidates to implement the Quick Sort algorithm on the spot. If you cannot write it when asked, the interview is likely to end there.</p>
<p>This note briefly records 10 classic sorting algorithms and 2 less common but practical sorting algorithms.</p>
<h2 id="Stability"><a href="#Stability" class="headerlink" title="Stability"></a>Stability</h2>
<p>Many materials and documents mention the concept of <strong>stability</strong> when discussing sorting. What is stability? What is its use?</p>
<h3>Stability</h3>
<p>Stability refers to whether the relative order of equal elements changes after sorting.</p>
<p>For example, in the array [3, 7, 3', 2], if after sorting, the order of 3 and 3' changes, then the sorting is unstable.</p>
<h3>Significance of Stability</h3>
<ul>
  <li>It can save time since a stable sorting algorithm reduces one swap time.</li>
  <li>When sorting by one key and then by another, the result of the first key sort can be used in the second key sort.</li>
</ul>
<p><strong>Stable</strong> sorting algorithms:</p>
<ul><li>Radix Sort, Counting Sort, Insertion Sort, Bubble Sort, Merge Sort</li></ul>
<p><strong>Unstable</strong> sorting algorithms:</p>
<ul><li>Selection Sort, Heap Sort, Quick Sort, Shell Sort</li></ul>
<p>From a beginner's perspective, the stability of a sorting algorithm might not seem important, which is understandable (as I used to think so). Beginners might focus more on the <strong>process</strong> of a sorting algorithm. Having practiced many LeetCode problems without much real-world experience, one might <strong>mistakenly believe that time complexity and space complexity are the only two metrics to evaluate sorting algorithm performance.</strong></p>
<p>However, in some application scenarios, stability is very important. For instance, when the original order of the target array has significance, an unstable algorithm might disrupt this order.</p>
<p>E.g.</p>
<p style="font-style: italic;">
  "If a class of students is already sorted by student ID, and now they need to be sorted by age from youngest to oldest. If the ages are the same, they must be sorted by student ID in ascending order. In this case, if an unstable sorting algorithm is used to sort by age, the order of student IDs in a group of students with the same age will be messed up, requiring the student ID sort to be repeated. But if the sorting algorithm is stable, sorting by age alone will complete the task."
</p>
<h2 id="SelectionSort"><a href="#SelectionSort" class="headerlink" title="SelectionSort"></a>Algorithm 1: Selection Sort</h2>
<p>Selection Sort is the simplest and most intuitive sorting algorithm. It works by finding the i-th smallest element each time and then swapping it with the element at the i-th position. As long as i is guaranteed to increase monotonically from 0 to n, sorting will be completed.</p>
<h3>Stability</h3>
<p>Since Selection Sort involves swapping two elements, it is an <strong>unstable</strong> sorting algorithm.</p>
<h3>Time Complexity</h3>
<p>O(n^2)</p>
<h3>Code Example (Python3)</h3>
<pre >
  def selection_sort(arr, n):
      for i in range(n):
          min_idx = i
          for j in range(i + 1, n):
              if arr[j] &lt arr[min_idx]:
                  min_idx = j
          arr[i], arr[min_idx] = arr[min_idx], arr[i]
</pre>
<h2 id="BubbleSort"><a href="#BubbleSort" class="headerlink" title="BubbleSort"></a>Algorithm 2: Bubble Sort</h2>
<p>Bubble Sort is one of the simplest sorting algorithms. It is named Bubble Sort because its sorting logic makes the smaller/larger elements "bubble up" to the top of the array, like bubbles rising in water.</p>
<h3>Execution Process</h3>
<p>Continuously check two adjacent elements, and if the front element and the back element violate the sorting principle, swap the two elements.</p>
<p><strong>Stopping Condition:</strong> When no adjacent elements need to be swapped in a round of traversal, the sorting is complete.</p>
<p><strong>Sorting Logic:</strong> The i-th round of scanning places the i-th largest/smallest element in the correct position.</p>
<h3>Stability</h3>
<p>Bubble Sort is a <strong>stable</strong> sorting algorithm.</p>
<h3>Time Complexity</h3>
<p>If the array is already sorted, Bubble Sort is equivalent to just traversing the array without performing any swaps, so the complexity is O(n).</p>
<p>In the worst case, the complexity is O(n^2).</p>
<h3>Code Example (Python3)</h3>
<pre>
def bubble_sort(a, n):
    flag = True
    while flag:
        flag = False
        for i in range(1, n):
            if a[i] > a[i + 1]:
                flag = True
                a[i], a[i + 1] = a[i + 1], a[i]
</pre>
<h3>Bubble Sort VS Selection Sort</h3>
<p>Firstly, from the perspective of <strong>sorting logic</strong>, Bubble Sort and Selection Sort share the same logic but execute in reverse order (Selection Sort sorts the left part of the array first, while Bubble Sort sorts the right part first).</p>
<p>The main difference between the two lies in their <strong>comparison and swap mechanisms</strong>, creating a classic tradeoff between stability and the number of swaps.</p>
<ul>
  <li>Bubble Sort relies on adjacent comparison and swap, <strong>ensuring stability but may require more rounds of swaps</strong>.</li>
  <li>Selection Sort finds the extreme value in the unsorted part through traversal and then swaps, <strong>reducing the number of swaps but sacrificing stability</strong>.</li>
</ul>

<h2 id="InsertionSort"><a href="#InsertionSort" class="headerlink" title="InsertionSort"></a>Algorithm 3: Insertion Sort</h2>
<p>
  Insertion sort is also a very intuitive and simple sorting algorithm. For those who often play cards (like me), insertion sort is the easiest algorithm to understand because the process of arranging cards in hand after picking them up from the table is essentially insertion sort: pick up a card from the table and insert it into the correct position among the cards in your hand, then repeat with the next card.
</p>
<p>
  Abstractly, the working principle of insertion sort can be summarized as:
  <strong>Divide the elements to be sorted into two parts: "sorted" and "unsorted". Each time, pick an element from the "unsorted" part and insert it into the correct position in the "sorted" part.</strong>
</p>
<div style="text-align: center;">
  <img src="../img/insert-sort.png" srcset="/img/loading.gif" lazyload alt="Insert Sort" width="550">
</div>

<h3>Stability</h3>
<p>Insertion sort is a <strong>stable</strong> sorting algorithm.</p>

<h3>Time Complexity</h3>
<p>If the array is already sorted or nearly sorted, the efficiency is very high. Because insertion sort essentially only traverses the original array once and always inserts elements at the end of the new array without needing to rearrange, the complexity is: O(n)</p>
<p>In the worst case, the complexity is: O(n^2)</p>

<h3>Code Example (Python3)</h3>
<pre>
def insertion_sort(arr, n):
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j = j - 1
        arr[j + 1] = key
</pre>

<h3>Advanced: Binary Insertion Sort</h3>

<p>Also known as <strong>Binary Insertion Sort</strong>. It aims to optimize performance through binary search, with the optimization being more noticeable when sorting a large number of elements.</p>
<p>However, since the basic idea of binary insertion sort is the same as direct insertion sort, binary insertion sort only optimizes the constant factor in the time complexity of insertion sort, so the <strong>optimized time complexity remains unchanged</strong>.</p>

<h4>Code Example (Python3)</h4>
<pre>
def insertion_sort(arr, n):
    if n &lt 2: return
    for i in range(1, n):
        key = arr[i]
        index = bisect.bisect_right(arr[:i], key)
        arr[index+1:i+1] = arr[index:i]
        arr[index] = key
</pre>

<h2 id="CountSort"><a href="#CountSort" class="headerlink" title="CountSort"></a>Algorithm 4: Counting Sort</h2>

<p>
  <strong>Counting sort is a linear time sorting algorithm.</strong>
  The linear time complexity is achieved by trading off space. An additional array, let's call it C, is used during the counting sort process, while the original array is referred to as A. During the traversal of A, the value of A[i] is used as an index to find the corresponding position in C, and then increment the count at that position.
</p>

<p>
  By doing this, all the values are naturally sorted just by traversing the C array by index. Finally, make sure to handle duplicate values correctly by counting them to ensure they are not missed.
</p>

<h3>Stability</h3>
<p>Counting sort is a <strong>stable</strong> sorting algorithm.</p>

<h3>Time Complexity</h3>
<p>The time complexity of counting sort is linear.</p>
<p>In the worst case, the complexity is: O(n + w), where w is the size of the auxiliary array.</p>

<h3>Code Example (Python3)</h3>
<pre>
min_value, max_value = 0, 100
cnt = [0] * max_value  

def counting_sort(arr, n):
    for i in range(n):
        cnt[arr[i]] += 1
    sorted_index = 0
    for i in range(max_value):
        while cnt[i] > 0:
            arr[sorted_index] = i
            cnt[i] -= 1
            sorted_index += 1
</pre>

<h2 id="RadixSort"><a href="#RadixSort" class="headerlink" title="RadixSort"></a>Algorithm 5: Radix Sort</h2>

<p>The counting sort discussed in the previous section has a critical flaw: the size of the auxiliary array is completely constrained by the maximum and minimum values. For example, if you perform a counting sort on the array [100000,1], you would need to create an auxiliary array of at least 100001 in length, which is very wasteful. Radix sort addresses this problem to some extent.
</p>

<p>Radix sort is a non-comparative integer sorting algorithm that works by cutting the integers into different digits and then comparing them digit by digit. 
<strong>In this way, the size of the auxiliary array can be controlled. This controllable auxiliary array is also called a "bucket." The concept of "buckets" is utilized in radix sort, counting sort, and the bucket sort we will discuss later.</strong></p>
<p>Since integers can also represent strings (like names or dates) and certain formats of floating-point numbers, radix sort is not limited to integers.</p>
<p>E.g., Perform radix sort on an array with a maximum value of 50.</p>
<p>In the first round, establish a "bucket" with a range of [0, 9] and sort the elements by the units digit.</p>
<div style="text-align: center;">
  <img src="../img/radix-sort1.png" srcset="/img/loading.gif" lazyload alt="Radix Sort Keyword 1" width="550">
</div>

<p>In the second round, establish another "bucket" with a range of [0, 9] and sort the elements by the tens digit, finally completing the overall sorting.</p>
<div style="text-align: center;">
  <img src="../img/radix-sort1.png" srcset="/img/loading.gif" lazyload alt="Radix Sort Keyword 1" width="550">
</div>

<h3>Types of Radix Sort</h3>
<ul>
  <li>If the comparison is made from the 1st digit to the k-th digit, this type of radix sort is called MSD (Most Significant Digit first) radix sort.</li>
  <li>If the comparison is made from the k-th digit to the 1st digit, this type of radix sort is called LSD (Least Significant Digit first) radix sort.</li>
</ul>

<h3>Stability</h3>
<p>If you look at the sorting of any individual layer of digits, like counting sort, it is a <strong>stable</strong> sort. 
  However, the sorting of the second layer of digits cannot guarantee the stability of the sorting achieved in the first layer. 
  Conversely, it can be said: <br>
  <strong>If the sorting of the inner layer of digits is stable, then both MSD radix sort and LSD radix sort are stable sorting algorithms.</strong>
</p>

<h3>Time Complexity</h3>
<p>Since the range of digit values is difficult to define, the worst-case scenario is too broad to discuss, but it can generally be understood as <strong>O(kn + kw)</strong>, where k is the number of digits, and w is the range of the digit values (assuming each digit has the same range of values).</p>
<p>In general, radix sort is faster than comparison-based sorting algorithms like quicksort.</p>

<h3>Code Example (Python3)</h3>
<pre>
def radix_sort(arr, max_digit):
    mod = 10
    dev = 1
    for i in range(max_digit):
        counter = [[] for _ in range(10)]
        for num in arr:
            bucket = (num % mod) // dev
            counter[bucket].append(num)
        pos = 0
        for bucket in counter:
            for num in bucket:
                arr[pos] = num
                pos += 1
        dev *= 10
        mod *= 10
    return arr
</pre>

<h2 id="BucketSort"><a href="#BucketSort" class="headerlink" title="BucketSort"></a>Algorithm 6: Bucket Sort</h2>

<p>As mentioned in radix sort, the concept of "buckets" is used, and the basic sorting idea is consistent. Bucket sort is more suitable when the data to be sorted has a large range of values but is distributed relatively evenly.</p>

<h3>Execution Process</h3>
<p>Bucket sort is carried out in the following steps:</p>
<ol>
  <li>Set up a fixed number of arrays to act as empty buckets.</li>
  <li>Traverse the sequence, placing each element into the corresponding bucket.</li>
  <li>Sort each non-empty bucket.</li>
  <li>Place the elements from the non-empty buckets back into the original sequence.</li>
</ol>

<h3>Stability</h3>
<p>Like radix sort, if the sorting within each bucket is stable, then bucket sort is also a stable sort.</p>
<p>However, this is based on certain assumptions, because unlike radix sort, bucket sort may alter the order of elements when placing them into buckets. Generally, if each bucket contains only a few elements, insertion sort can be used, making bucket sort a stable sorting algorithm in such cases.</p>

<h3>Time Complexity</h3>
<p>Overall, the time complexity is approximately: <strong>O(n + n^2/k + k) (dividing the range into n buckets + sorting + recombining elements)</strong></p>
<ul>
  <li>When n is much larger than k, it approaches O(n^2).</li>
  <li>When k is much larger than n (which is rare), it approaches O(k).</li>
  <li>When n is approximately equal to k, the time complexity approaches linear, O(n).</li>
  <li>The worst-case time complexity of bucket sort is O(n^2).</li>
</ul>

<h3>Code Example (Python3)</h3>
<pre>
N = 100010
w = n = 0
a = [0] * N
bucket = [[] for i in range(N)]
  
def insertion_sort(A):
    for i in range(1, len(A)):
        key = A[i]
        j = i - 1
        while j >= 0 and A[j] > key:
            A[j + 1] = A[j]
            j -= 1
        A[j + 1] = key
  
  
def bucket_sort():
    bucket_size = int(w / n + 1)
    for i in range(0, n):
        bucket[i].clear()
    for i in range(1, n + 1):
        bucket[int(a[i] / bucket_size)].append(a[i])
    p = 0
    for i in range(0, n):
        insertion_sort(bucket[i])
        for j in range(0, len(bucket[i])):
            a[p] = bucket[i][j]
            p += 1
</pre>

<h3>Radix Sort vs Counting Sort vs Bucket Sort</h3>
<ul>
  <li>Radix Sort: Distributes the elements into buckets based on each digit of the key.</li>
  <li>Counting Sort: Each bucket stores only a single key value.</li>
  <li>Bucket Sort: Each bucket stores a range of values.</li>
</ul>

<h2 id="MergeSort"><a href="#MergeSort" class="headerlink" title="MergeSort"></a>Algorithm 7: Merge Sort</h2>

<p>Merge sort is a sorting algorithm that often discourages beginners because it is based on the divide-and-conquer strategy to sort array segments and then merge them. Therefore, mastering this algorithm requires a slightly higher level of understanding.</p>

<h3>Execution Process</h3>
<p>To implement merge sort using the divide-and-conquer method, you can follow these steps during recursion:</p>
<ol>
  <li>If the array length is 1, the array is already sorted, so no further division is needed.</li>
  <li>If the array length is greater than 1, the array is likely unsorted. At this point, divide the array into two segments, and then check if each segment is sorted (using step 1).</li>
    <ul>
      <li>If sorted, merge them into one sorted array.</li>
      <li>If not sorted, repeat step 2 on the unsorted segment, then merge.</li>
    </ul>
</ol>

<h4>Division</h4>
<p>To ensure the complexity of the sort, the array is usually divided into two segments of approximately equal length: mid = floor((l+r) / 2)</p>

<h4>Merge</h4>
<p>From an implementation perspective, the core part of merge sort is the merge process.</p>
<p>The goal is to merge two sorted arrays a[i] and b[j] into one sorted array c[k].</p>
<p>This can be easily achieved using the two-pointer method:
  <strong>Enumerate a[i] and b[j] from left to right, find the smallest value and place it into array c[k]; repeat the process until either a[i] or b[j] is empty, then place the remaining elements of the other array into c[k].</strong></p>

<h3>Stability</h3>
<p>As long as you ensure that the merge process uses <= comparisons, you can avoid inserting the right-side numbers before the left-side numbers when there are duplicates. 
  <strong>In this case, merge sort is stable.</strong>
</p>

<h3>Time Complexity</h3>
<p>The average time complexity is:
  <strong>O(nlog(n))</strong>
</p>

<h3>Code Example (Python3)</h3>
<pre>
def merge(a, b):
    i, j = 0, 0
    c = []
    while i &lt len(a) and j &lt len(b):
        if b[j] &lt a[i]:
            c.append(b[j])
            j += 1
        else:
            c.append(a[i])
            i += 1
    c.extend(a[i:])
    c.extend(b[j:])
    return c

def merge_sort(a, ll, rr):
    if rr - ll &lt= 1:
        return
    mid = (rr + ll) // 2
    merge_sort(a, ll, mid)
    merge_sort(a, mid, rr)
    a[ll:rr] = merge(a[ll:mid], a[mid:rr])
</pre>

<h2 id="QuickSort"><a href="#QuickSort" class="headerlink" title="QuickSort"></a>Algorithm 8: Quick Sort</h2>

<p>Quick sort, also known as "partition-exchange sort," is currently one of the most widely used sorting algorithms. It is also one of the most likely sorting algorithms to be tested in interviews.</p>

<h3>Execution Process</h3>
<p>Similar to merge sort, the working principle of quick sort is also to sort an array through the <strong>divide and conquer</strong> method.</p>
<p>However, unlike merge sort, the first step is not to directly divide the sequence into two parts; <strong>instead, the relative size relationship must be ensured during the division process.</strong></p>
<p>Specifically, the first step is to divide the sequence into two parts while ensuring that the numbers in the first sub-sequence are smaller than those in the second sub-sequence. To ensure average time complexity, a random number m is usually chosen as the boundary between the two sub-sequences (thus, the elements in the array can be quickly categorized: greater than m or less than m).</p>

<p>Next, maintain two pointers, p and q, starting from the front and back, respectively. For each current number, consider whether it is in the correct position (in the front or back). If the current number is not in the correct position, for example, if the back pointer q encounters a number smaller than m, you can swap the numbers at p and q, then move p one position forward.
  Once all current numbers are in the correct positions, move the pointers and continue processing until the two pointers meet.</p>
<p>In fact, quick sort does not specify exactly how to implement the first step. There are multiple ways to choose m and perform the division.</p>

<p>Quick sort involves three steps:</p>
<ol>
  <li>Divide the sequence into two parts (ensuring the relative size relationship).</li>
  <li>Recursively perform quick sort on the two sub-sequences.</li>
  <li>No merging is required because the sequence is already fully sorted by this point.</li>
</ol>

<p><img decoding="async" src="//www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="Runoob.com QuickSort GIF Demo" /></p>

<h3>Stability</h3>
<p>Quick sort is a <strong>non-stable</strong> sorting algorithm.</p>

<h3>Time Complexity</h3>
<ul>
  <li>The best-case time complexity is: <strong>O(nlog(n))</strong> (when the selected pivot is always the median of the sequence).</li>
  <li>The average time complexity is: <strong>O(nlog(n))</strong></li>
  <li>The worst-case time complexity is: <strong>O(n^2)</strong> (when the selected pivot is always the extreme value of the sequence).</li>
</ul>

<h3>Code Example (Python3)</h3>

<pre>
def quick_sort(alist, first, last):
    if first >= last:
        return
    mid_value = alist[first]
    low = first
    high = last
    while low &lt high:
        while low &lt high and alist[high] >= mid_value:
            high -= 1
        alist[low] = alist[high]
        while low &lt high and alist[low] &lt mid_value:
            low += 1
        alist[high] = alist[low]
    alist[low] = mid_value
    quick_sort(alist, first, low - 1)
    quick_sort(alist, low + 1, last)
</pre>

<h2 id="HeapSort"><a href="#HeapSort" class="headerlink" title="HeapSort"></a>Algorithm 9: Heap Sort</h2>

<p>Heap sort is a sorting algorithm designed using the <strong>binary heap</strong> data structure. Initially, I felt it might be a bit off-topic since this note is meant to organize sorting algorithms and is nominally part of the <strong>"Array Series"</strong>. However, considering that heaps can be built on arrays and despite its sorting essence being based on heap-based selection sort, it does not prevent it from sorting arrays. It only adds <strong>heap creation</strong> and <strong>array reconstruction</strong>.</p>

<h3>Execution Process</h3>
<ul>
  <li>First, build a max-heap or min-heap based on the sorting requirement. Then, remove the top element of the heap, which is the maximum value, swap it with the element at the end of the array, and maintain the properties of the remaining heap.</li>
  <li>Next, remove the top element of the heap, which is the second-largest value, swap it with the element at the second-to-last position in the array, and maintain the properties of the remaining heap.</li>
  <li>Repeat this process, and after the nth-1 operation, when the heap is empty, the array will be naturally sorted.</li>
</ul>

<h4>About "Heap"</h4>
<strong>I do not plan to elaborate on the binary heap details in the sorting algorithms section, as I intend to systematically organize heaps and stacks in another section.</strong>
<p>However, I can briefly mention why binary heaps do not require a specific tree structure and can be created directly in an array.</p>
<p>By observing the tree structure of a binary heap, one can see that each node in the binary heap is counted from top to bottom and left to right. The total number of nodes before a node is exactly twice the count of its parent node, with the left child including itself (+1) and the right child including itself and the left child (+2).</p>
<p><strong>This relationship can be directly applied to index multiplication relationships in arrays.</strong></p>
<pre>
iParent(i) = (i - 1) / 2;
iLeftChild(i) = 2 * i + 1;
iRightChild(i) = 2 * i + 2;
</pre>

<h3>Stability</h3>
<p>Like selection sort, due to the swapping operations, heap sort is a <strong>non-stable</strong> sorting algorithm.</p>

<h3>Time Complexity</h3>
<p>For binary heaps, the time complexity is directly <strong>O(nlogn)</strong></p>

<h3>Code Example (Python3)</h3>

<pre>
def sift_down(arr, start, end):
    parent = int(start)
    child = int(parent * 2 + 1)
    while child &lt= end:
        if child + 1 &lt= end and arr[child] &lt arr[child + 1]:
            child += 1
        if arr[parent] >= arr[child]:
            return
        else:
            arr[parent], arr[child] = arr[child], arr[parent]
            parent = child
            child = int(parent * 2 + 1)

def heap_sort(arr, len):
    i = (len - 1 - 1) / 2
    while i >= 0:
        sift_down(arr, i, len - 1)
        i -= 1
    i = len - 1
    while i > 0:
        arr[0], arr[i] = arr[i], arr[0]
        sift_down(arr, 0, i - 1)
        i -= 1
</pre>



<h2 id="ShellSort"><a href="#ShellSort" class="headerlink" title="ShellSort"></a>Algorithm 10: Shell Sort</h2>

<p>Shell sort, also known as the increment decrement sort, is an improved version of <strong>insertion sort</strong>. It is one of the first algorithms to break through O(n^2) efficiency in the mid-20th century.</p>

<p>The inventor, Donald Shell, proposed the improvement method based on the following properties of insertion sort:</p>
<ul>
  <li>Insertion sort is efficient for nearly sorted data, achieving linear sorting efficiency.</li>
  <li>However, insertion sort is generally inefficient because it can only move data one position at a time.</li>
</ul>

<h3>Execution Process</h3>
<p><strong>Shell sort groups records based on a certain increment of indices, performs insertion sort on each group, and gradually reduces the increment. As the increment decreases, each group contains more keywords. When the increment reaches 1, the entire file is divided into one group, and the algorithm terminates.</strong></p>
<p>Sorting compares and moves non-adjacent records:</p>
<ol>
  <li>Divide the sequence to be sorted into several subsequences (where the elements of each subsequence are spaced equally in the original array).</li>
  <li>Perform insertion sort on these subsequences.</li>
  <li>Reduce the spacing between elements in each subsequence and repeat the process until the spacing is reduced to 1.</li>
</ol>

<h4>Flowchart</h4>
<div style="text-align: center;">
  <img src="../img/shell-sort-en.png" srcset="/img/loading.gif" lazyload alt="Shell Sort" width="550">
</div>

<h3>Stability</h3>
<p>Shell sort is a <strong>non-stable</strong> sorting algorithm.</p>

<h3>Time Complexity</h3>
<p>The best-case time complexity of Shell sort is <strong>O(n)</strong>.</p>
<p>However, the average time complexity and worst-case time complexity of Shell sort depend on the choice of the increment sequence:</p>
<ul>
  <li>If the increment sequence is not chosen properly, the complexity of the sorting algorithm can degrade to O(n^2).</li>
</ul>

<p>Shell sort itself is not complex, but its time complexity has a well-developed and complex proof. This was the main work of Donald Shell after he improved the algorithm in 1959. The specific process of proving the time complexity, as well as the lemmas and theorems used, will not be elaborated here. Interested readers can refer to <a href="https://oi-wiki.org/basic/shell-sort/">this link</a>.</p>

<h3>Code Example (Python3)</h3>

<pre>
import math
def shellSort(arr):
    gap=1
    while(gap &lt len(arr)/3):
        gap = gap*3+1
    while gap > 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j >=0 and arr[j] > temp:
                arr[j+gap]=arr[j]
                j-=gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
</pre>

<h2 id="TournamentSort"><a href="#TournamentSort" class="headerlink" title="TournamentSort"></a>Algorithm 11: Tournament Sort</h2>

<p>
  Tournament sort is named after the single-elimination tournament format. In this format, many participants compete, comparing in pairs, with the winner advancing to the next round. This elimination method can be represented as a complete binary tree, where you can determine the number 1 by looking at the root.
</p>

<p>At first glance, it is quite similar to heap sort, but there are significant differences. In heap sort, after removing the top element, the new top is the second largest/smallest element. However, in tournament sort, the player eliminated in the final round is not necessarily the second best, as they might be worse than previously eliminated players (e.g., the second player might have been eliminated in the first round by the first player).</p>

<p>
  Therefore, tournament sort, also known as tree-based selection sort, actually uses the idea of heap sort (priority queue) on top of selection sort to find the next element to be selected. <strong>It is an optimized version of selection sort and a variant of heap sort (both use a complete binary tree).</strong>
</p>

<h3>Execution Process</h3>
<p>For example, with the array [7, 2, 3, 4, 6, 10, 8, 5], performing a minimum tournament sort would result in a tournament tree as shown below:</p>
<div style="text-align: center;">
  <img src="../img/tournament1.png" srcset="/img/loading.gif" lazyload alt="Tournament Sort Round 1" width="550">
</div>

<p>Clearly, 2 is the smallest element and can be removed first. After one "tournament," the selected element needs to be removed. Set it to +INF (for maximum sorting use -INF), then hold another "tournament" to find the next smallest element.</p>
<div style="text-align: center;">
  <img src="../img/tournament2.png" srcset="/img/loading.gif" lazyload alt="Tournament Sort Round 2" width="550">
</div>

<p>Repeat this process until all elements are sorted.</p>

<h3>Stability</h3>

<p>Tournament sort is a <strong>non-stable</strong> sorting algorithm.</p>

<h3>Time Complexity</h3>

<p>The best, average, and worst-case time complexities are all <strong>O(nlogn)</strong>.</p>
<p>Initializing the tournament tree requires O(n) time, and each "tournament" takes O(logn) time, repeated n times.</p>

<p><strong>Code implementation is omitted here; the concept is not complex, but it requires functions for "initialization," "competition," and "repeated matches."</strong></p>

<h2 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>Algorithm 12: Tim Sort</h2>

<p>
  <strong>Tim sort is a hybrid of merge sort and insertion sort. It is currently one of the most sophisticated sorting algorithms I have encountered. Developed by Tim Peters in 2002 using Python, Tim sort is the standard sorting algorithm in Python, and it is also used by Java SE7 for sorting arrays of non-primitive types.</strong>
</p>

<h3>Execution Process</h3>

<p>Merge sort first divides the array into two parts, then recursively performs merge sort on the two subarrays, and finally merges the two subarrays. The smallest unit of merge sort operations is a single element.</p>
<p>However, there may already be contiguous and sorted subarrays within the array, which merge sort cannot utilize.</p>

<h4>RUN Units</h4>
<p>Tim sort takes advantage of the contiguous and sorted subarrays by using RUN as the smallest unit for merge operations. A RUN is a subarray with the following properties:</p>
<ul>
  <li>A RUN is either non-decreasing or strictly increasing.</li>
  <li>A RUN has a minimum length requirement.</li>
</ul>
<p>Tim sort operates similarly to merge sort by dividing the array into multiple RUNs and then repeatedly merging two RUNs according to certain rules until the array is sorted.</p>

<h3>Stability</h3>

<p>Tim sort is a <strong>stable</strong> sorting algorithm.</p>

<h3>Time Complexity</h3>
<ul>
  <li>The best-case time complexity is <strong>O(n)</strong>.</li>
  <li>The worst-case time complexity is <strong>O(nlogn)</strong>.</li>
</ul>

<h3>Code Example (Java)</h3>
<p><strong>The following is an implementation in Java SE7.</strong></p>


<pre>
class TimSort implements SortAlgorithm {
    private static final int SUB_ARRAY_SIZE = 32;
    private Comparable[] aux;

    @Override
    public &ltT extends Comparable&ltT>> T[] sort(T[] a) {
        int n = a.length;
        InsertionSort insertionSort = new InsertionSort();
        for (int i = 0; i &lt n; i += SUB_ARRAY_SIZE) {
            insertionSort.sort(a, i, Math.min(i + SUB_ARRAY_SIZE, n));
        }
        aux = new Comparable[n];
        for (int sz = SUB_ARRAY_SIZE; sz &lt n; sz = sz + sz) {
            for (int lo = 0; lo &lt n - sz; lo += sz + sz) {
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, n - 1));
            }
        }
        return a;
    }

    private &ltT extends Comparable&ltT>> void merge(T[] a, int lo, int mid, int hi) {
        int i = lo;
        int j = mid + 1;
        System.arraycopy(a, lo, aux, lo, hi + 1 - lo);
        for (int k = lo; k &lt= hi; k++) {
            if (j > hi) {
                a[k] = (T) aux[i++];
            } else if (i > mid) {
                a[k] = (T) aux[j++];
            } else if (less(aux[j], aux[i])) {
                a[k] = (T) aux[j++];
            } else {
                a[k] = (T) aux[i++];
            }
        }
    }
}
</pre>


<h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>References</h2>
<ul>
  <li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">Programmer Carl: Basic Array Theory</a></li>
  <li><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/127449">What Does the "Stability" of Sorting Algorithms Mean?</a></li>
  <li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/quick-sort-2.html">Rookie Tutorial: 1.6 Quick Sort</a></li>
  <li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/radix-sort.html">Rookie Tutorial: 1.10 Radix Sort</a></li>
  <li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6104371.html">Illustrated Sorting Algorithms (Part II) - Shell Sort</a></li>
  <li><a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/sort-intro/">OI Wiki: Sorting Series</a></li>
  <li><a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/divide-and-conquer/">OI Wiki: Recursion & Divide and Conquer</a></li>
  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/top-interview-150/">Leetcode: Top 150 Interview Questions</a></li>
  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/premium-algo-100/">Leetcode: Premium Interview 100 Questions</a></li>
  <li><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/">Leetcode Algorithms</a></li>
  <li><a target="_blank" rel="noopener" href="https://github.com/TheAlgorithms/Java/blob/master/src/main/java/com/thealgorithms/sorts/TimSort.java">GitHub: Java Algorithm - TimSort</a></li>

</ul>
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
      <a href="/tags/General/Tech/" class="print-no-link">#Tech</a>
    </div>
  
</div>



  <div class="license-box my-3">
    <div class="license-title">
      <div>Data Structure and Algorithm - Array(II): Sorting</div>
      <div>https://billyjojojobulidogithub.io/notes/Algorithm/sort/english/index.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Baocheng Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 08, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                    <i class="iconfont icon-nc"></i>
                    <i class="iconfont icon-nd"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>

                <div class="post-prevnext my-3">
                  <!-- <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/30/USYD/" title="USYD Graduation">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Baocheng's Graduation from the University of Sydney</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/15/Navigator/" title="Government Infrastructure Performance Navigator">
                        <span class="hidden-mobile">Government Infrastructure Performance Navigator</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article> -->
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>

      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  

</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function(){
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document){
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing){
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function(){
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot){ return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0){
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function(){
      if ('tocbot' in window){
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot){
          return;
        }
        if (toc.find('.toc-list-item').length > 0){
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function(){
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon){
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el){
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left'){
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function(){
      if ('anchors' in window){
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el){
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left'){
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function(){
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项,将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
