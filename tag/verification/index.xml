<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Verification | Nir Lipovetzky</title>
    <link>https://nirlipo.github.io/tag/verification/</link>
      <atom:link href="https://nirlipo.github.io/tag/verification/index.xml" rel="self" type="application/rss+xml" />
    <description>Verification</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Thu, 02 Jun 2016 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://nirlipo.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Verification</title>
      <link>https://nirlipo.github.io/tag/verification/</link>
    </image>
    
    <item>
      <title>Trapper</title>
      <link>https://nirlipo.github.io/project/trapper/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      <guid>https://nirlipo.github.io/project/trapper/</guid>
      <description>
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/dn46rqa6fnc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;We consider the problem of deriving formulas that capture traps, invariants, and dead-ends in classical planning through polynomial forms of preprocessing. An invariant is a formula that is true in the initial state and in all reachable states. A trap is a conditional invariant: once a state is reached that makes the trap true, all the states that are reachable from it will satisfy the trap formula as well. Finally, dead-ends are formulas that are satisfied in states that make the goal unreachable. We introduce a preprocessing algorithm that computes traps in k-DNF form that is exponential in the k parameter, and show how the algorithm can be used to precompute invariants and dead-ends. We report also preliminary tests that illustrate the effectiveness of the preprocessing algorithm for identifying dead-end states, and compare it with the identification that follows from the use of the h^1 and h^2 heuristics that cannot be preprocessed, and must be computed at run time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linear Temporal Logic, Planning and Synthesis</title>
      <link>https://nirlipo.github.io/project/ltl/</link>
      <pubDate>Sun, 02 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://nirlipo.github.io/project/ltl/</guid>
      <description>&lt;p&gt;In this project we showed how to compute infinte plans for LTL goals. Infinite plans are akin to the problem of control synteshis. Given an LTL formula, the tools developed encodes the LTL goal formula as Deterministic Buchi Automata states. The Automata is encoded along with the allowed transitions of the agent in the Planning Domain Description Language (PDDL). The problem becomes a fully observable non-deterministic planning problem (FOND) or a classical problem, depending on whether the environment can act non-deterministically.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
